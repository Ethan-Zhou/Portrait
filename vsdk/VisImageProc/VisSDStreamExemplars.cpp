// VisSDStreamExemplars.cpp
//
// Copyright © 2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////
#include "VisImageProcPch.h"
#include "VisImageProc.h"

CVisSDObject< CVisImageBase >		g_visimagebaseExemplar;
CVisSDObject< CVisSequenceBase >	g_vissequencebaseExemplar;

CVisSDObject< CVisVector4 >			g_visvector4Exemplar;
CVisSDObject< CVisTransform4x4 >	g_vistransform4x4Exemplar;

CVisSDObject< CVisDVector >			g_visdvectorExemplar;
CVisSDObject< CVisDMatrix >			g_visdmatrixExemplar;

CVisSDObject< CVisSprite >			g_visspriteExemplar;
CVisSDObject< CVisSpriteCollection > g_visspritecollectionExemplar;
CVisSDObject< CVisSpriteComposite > g_visspritecompositeExemplar;

#ifdef TAKEOUT

CVisSDObject< CVisTransformChain >	g_vistransformchainExemplar;

#endif // TAKEOUT


void CVisSDObject<CVisSprite>::AdjustFields() { } // use all fields

void CVisSDObject<CVisSpriteCollection>::AdjustFields() { } // use all fields

void CVisSDObject<CVisSpriteComposite>::AdjustFields() { } // use all fields

const char *CVisSequenceBase::ReadWriteField(CVisSDStream& s,
		int field_id)
{
#ifdef VIS_INCLUDE_SDSTREAM
    switch (FieldType(field_id))
	{
    case eftName:
        return "class CVisSequenceBase {";

    case eftProperties:
		s.NewLine();
		s.OpenParen();
		s.NewLine();
		SDReadWriteProperties(s);
		// UNDONE (in Rel1):  Skip extra fields until we get to the next brace.
		// UNDONE (in Rel1):  Should the (derived) class name be written to the file.
		s.CloseParen();
		return "std::list<void *> m_listProps;  // Properties";

    case eftImages:
		s.NewLine();
		s.OpenParen();
		s.NewLine();
		ReadWriteImages(s);
		// UNDONE (in Rel1):  Skip extra fields until we get to the next brace.
		s.CloseParen();
        return "std::deque<class CVisImageBase*> m_dequeImages;  // Images";
    }

    return 0;
#else
	assert(false);  //SDStreams are not included
	return 0;
#endif
}

void CVisSequenceBase::ReadSequenceInfo(const char *szFilename,
		bool fReadFiles, bool fChangeOptionsAndLengthMax)
{
#ifdef VIS_INCLUDE_SDSTREAM
	int iCur = ICur();
	bool fCalledSetLengthMax = m_fCalledSetLengthMax;
	int nLengthMax = m_nLengthMax;
	int evissequence = m_evissequence;

	// Note:  Ideally, this would be a const method, but we use self-describing
	// streams for the I/O, and they call non-const methods.
    CVisSDStream stream;
    stream.Open(szFilename, CVisSDStream::Read);

    stream << *this;
    stream.Close();

	if (!fChangeOptionsAndLengthMax)
	{
		m_evissequence = evissequence;

		SetICur(iCur);

		if (fCalledSetLengthMax)
		{
			SetLengthMax(nLengthMax);
		}
		else
		{
			m_fCalledSetLengthMax = fCalledSetLengthMax;
			m_nLengthMax = nLengthMax;
		}
	}

	if (fReadFiles)
		ReadFiles();
#else
	assert(false);
#endif
}


void CVisSequenceBase::WriteSequenceInfo(const char *szFilename,
		bool fWriteFiles)
{
#ifdef VIS_INCLUDE_SDSTREAM

	// Note:  Ideally, this would be a const method, but we use self-describing
	// streams for the I/O, and they call non-const methods.
    CVisSDStream stream(0);
    stream.Open(szFilename, CVisSDStream::Write);

	// LATER:  Do we want to add a comment string to the stream?
//    string comment = "\ngenerated by: ";
//    for (int i = 0; i < argc; i++)
//        comment += " " + string(argv[i]);

// UNDONE (in Rel1):  Can we make the writing of descriptions optional?  (If
// not, should CVisFrameSequemce make sure that CVisSequence is also described?)
    stream << *this;
    stream.Close();

	if (fWriteFiles)
		WriteFiles();
#else
	assert(false);
#endif
}


bool CVisSequenceBase::FReadSequenceInfo(const char *szFilename,
		bool fReadFiles, bool fChangeOptionsAndLengthMax)
{
#ifdef VIS_INCLUDE_SDSTREAM
	bool fRet = false;
	CVisSequenceBase *psequenceClone = 0;

	try
	{
		psequenceClone = Clone();
		
		// New should throw an exception, but we check the return in case that
		// option is not used.
		if (psequenceClone != 0)
		{
			psequenceClone->ReadSequenceInfo(szFilename, fReadFiles,
					fChangeOptionsAndLengthMax);

			fRet = true;

			*this = *psequenceClone;
		}
	}
	catch (...)
	{
	}

	if (psequenceClone != 0)
	{
		delete psequenceClone;
		psequenceClone = 0;
	}

	return fRet;
#else
	assert(false);
return false;
#endif
}


bool CVisSequenceBase::FWriteSequenceInfo(const char *szFilename,
		bool fWriteFiles)
{
#ifdef VIS_INCLUDE_SDSTREAM
	bool fRet = false;

	try
	{
		WriteSequenceInfo(szFilename, fWriteFiles);

		fRet = true;
	}
	catch (...)
	{
	}

	return fRet;
#else
	assert(false);
	return false;
#endif
}

//
// Reading and writing descriptions
//

const char *CVisImageBase::ReadWriteField(CVisSDStream& s, int field_id)
{
#ifdef VIS_INCLUDE_SDSTREAM

    switch (FieldType(field_id))
	{
    case eftName:
        return "class CVisImageBase {";
		
	case eftPixFmt:
		if (s.Status() == CVisSDStream::Read)
		{
			int w;
			s.Num(w, true);
			assert(m_evispixfmt == w);
			if (m_evispixfmt != w)
			{
				throw CVisError(
					"Pixel type mismatch when reading image information",
					eviserrorTypeMismatch, "CVisImageBase::ReadWriteField",
					__FILE__, __LINE__);
			}
		}
		else
		{
			s.NewLine();
			assert(sizeof(EVisPixFmt) == sizeof(int));
			s.Num((int&) m_evispixfmt, true);
		}
		return "EVisPixFmt m_evispixfmt;  // Pixel type";
		
    case eftShape:
		if (s.Status() == CVisSDStream::Read)
		{
			// We don't read the image from the self-describing stream,
			// but we will read its file name and timestamp below.  Here
			// we clear any previous image to indicate that we still need
			// to read this image from a file.
			Deallocate();
			
			// Still need to read a CVisShape from the stream.
			CVisShape shapeT;
			s << shapeT;
		}
		else
		{
			s.NewLine();
			s << m_shapeImage;
		}
        return "CVisShape m_shape;    // Dimensions and number of bands";
		
    case eftFilename:
		s.NewLine();
		s << m_strName;
		return "std::string m_strFilename;    // File name";
		
    case eftProperties:
		s.NewLine();
		s.OpenParen();
		s.NewLine();
		SDReadWriteProperties(s);
		// UNDONE (in Rel1):  Skip extra fields until we get to the next brace.
		// UNDONE (in Rel1):  Should the (derived) class name be written to the file.
		s.CloseParen();
		return "std::list<void *> m_listProps;  // Properties";
    }
	return 0;
#else
	assert(false);  //SDStreams are not included
	return 0;
#endif
}

const char *CVisTransform4x4::ReadWriteField(CVisSDStream& s, int field_id)
{
#ifdef VIS_INCLUDE_SDSTREAM
    switch (FieldType(field_id))
	{
    case eftName:
        return "class CVisTransform4x4 {";

    case eftData:
		// Use the old code to read or write from the stream.
		// LATER:  Should we change this?
		{
			for (int i = 0; i < 4; i++) {
				s.OpenParen();
				for (int j = 0; j < 4; j++) {
					s << (*this)[i][j];
					if (j < 3)
						s.Comma();
				}
				s.CloseParen();
				if (i < 3)
					s.Comma(), s.NewLine();
			}
		}
        return "double m_rgrgdbl[4][4];";
    }

    return 0;
#else
	assert(false);  // SDStreams are not included
	return 0;
#endif
}

const char *CVisDVector::ReadWriteField(CVisSDStream& s, int field_id)
{
#ifdef VIS_INCLUDE_SDSTREAM
    switch (FieldType(field_id))
	{
    case eftName:
        return "class CVisDVector {";

    case eftLength:
		if (s.Status() == CVisSDStream::Read)
		{
			int lengthNew = m_length;
			s << lengthNew;
			assert(lengthNew >= 0);
			if (lengthNew != m_length)
				Resize(lengthNew);
		}
		else
		{
			s << m_length;
		}
		return "int m_length;             // number of elements";

    case eftData:
		s.OpenParen();
		for (int i = 0; i < m_length; i++)
		{
			s << m_data[i];
			if (i < m_length - 1)
				s.Comma();
		}
		s.CloseParen();
        return "double m_data[m_length];  // elements";
    }

    return 0;
#else
	assert(false);  // SDStreams are not included
	return 0;
#endif
}

const char *CVisDMatrix::ReadWriteField(CVisSDStream& s, int field_id)
{
#ifdef VIS_INCLUDE_SDSTREAM
    switch (FieldType(field_id))
	{
    case eftName:
        return "class CVisDMatrix {";

    case eftDims:
		s.OpenParen();
		if (s.Status() == CVisSDStream::Read)
		{
			int nRowsNew = m_nRows;
			int nColsNew = m_nCols;
			s << nRowsNew;
			s.Comma();
			s << nColsNew;
			assert((nRowsNew >= 0) && (nColsNew >= 0));
			if ((nRowsNew != m_nRows) || (nColsNew != m_nCols))
				Resize(nRowsNew, nColsNew);
		}
		else
		{
			s << m_nRows;
			s.Comma();
			s << m_nCols;
		}
		s.CloseParen();
		return "int m_nRows, m_nCols;     // dimensions";

    case eftData:
		s.NewLine();
		s.OpenParen();
		for (int r = 0; r < m_nRows; r++) {
			s.OpenParen();
			for (int c = 0; c < m_nCols; c++) {
				s << (*this)[r][c];
				if (c < m_nCols - 1)
					s.Comma();
			}
			s.CloseParen();
			if (r < m_nRows - 1)
				s.Comma(), s.NewLine();
		}
		s.CloseParen();
		s.NewLine();
        return "double m_data[m_nRows][m_nCols];  // elements";
    }

    return 0;
#else
	assert(false);  // SDStreams are not included
	return 0;
#endif
}

const char *CVisVector4::ReadWriteField(CVisSDStream& s, int field_id)
{
#ifdef VIS_INCLUDE_SDSTREAM
    switch (FieldType(field_id))
	{
    case eftName:
        return "class CVisVector4 {";

    case eftData:
		// Use the old code to read or write from the stream.
		// LATER:  Should we change this?
		{
			// Don't print the last two elements, if standard
			CVisVector4 def(0, 0);
			if (s.Status() == CVisSDStream::Read)
				(*this) = def;
			s << (*this)[0], s.Comma(), s << (*this)[1];
			if ((*this)[2] != def[2] || (*this)[3] != def[3] || s.PeekChar() == ',')
				s.Comma(), s << (*this)[2];
			if ((*this)[3] != def[3] || s.PeekChar() == ',')
				s.Comma(), s << (*this)[3];
		}
        return "double m_rgdbl[4];  // x, y, (and optionally) z, and w components";
    }

    return 0;
#else
	assert(false);  // SDStreams are not included
	return 0;
#endif
}


